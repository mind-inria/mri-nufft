
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "generated/autoexamples/GPU/example_density.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_generated_autoexamples_GPU_example_density.py>`
        to download the full example code. or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_generated_autoexamples_GPU_example_density.py:


=============================
Density Compensation Routines
=============================

Examples of differents density compensation methods.

Density compensation depends on the sampling trajectory,and is apply before the
adjoint operation to act as preconditioner, and should make the lipschitz constant
of the operator roughly equal to 1.

.. GENERATED FROM PYTHON SOURCE LINES 15-19

.. colab-link::
   :needs_gpu: 1

   !pip install mri-nufft[gpunufft] finufft

.. GENERATED FROM PYTHON SOURCE LINES 21-23

Imports
-------

.. GENERATED FROM PYTHON SOURCE LINES 23-32

.. code-block:: Python

    import os
    import brainweb_dl as bwdl
    import matplotlib.pyplot as plt
    import numpy as np

    from mrinufft import get_density, get_operator
    from mrinufft.trajectories import initialize_2D_radial
    from mrinufft.trajectories.display import display_2D_trajectory








.. GENERATED FROM PYTHON SOURCE LINES 33-35

Create sample data
------------------

.. GENERATED FROM PYTHON SOURCE LINES 35-53

.. code-block:: Python


    BACKEND = os.environ.get("MRINUFFT_BACKEND", "finufft")

    mri_2D = np.flipud(bwdl.get_mri(4, "T1")[80, ...]).astype(np.float32)

    print(mri_2D.shape)

    traj = initialize_2D_radial(192, 192).astype(np.float32)

    nufft = get_operator(BACKEND)(traj, mri_2D.shape, density=False, squeeze_dims=True)
    kspace = nufft.op(mri_2D)
    adjoint = nufft.adj_op(kspace)

    fig, axs = plt.subplots(1, 3, figsize=(15, 5))
    axs[0].imshow(abs(mri_2D))
    display_2D_trajectory(traj, subfigure=axs[1])
    axs[2].imshow(abs(adjoint))




.. image-sg:: /generated/autoexamples/GPU/images/sphx_glr_example_density_001.png
   :alt: example density
   :srcset: /generated/autoexamples/GPU/images/sphx_glr_example_density_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (256, 256)
    /volatile/github-ci-mind-inria/gpu_mind_runner/_work/mri-nufft/venv/lib/python3.10/site-packages/mrinufft/_utils.py:94: UserWarning: Samples will be rescaled to [-pi, pi), assuming they were in [-0.5, 0.5)
      warnings.warn(

    <matplotlib.image.AxesImage object at 0x716cb4aeac80>



.. GENERATED FROM PYTHON SOURCE LINES 54-55

As you can see, the radial sampling pattern as a strong concentration of sampling point in the center, resulting in a  low-frequency biased adjoint reconstruction.

.. GENERATED FROM PYTHON SOURCE LINES 57-65

Geometry based methods
======================

Voronoi
-------

Voronoi Parcellation attribute a weights to each k-space coordinate, inversely
proportional to its voronoi cell area.

.. GENERATED FROM PYTHON SOURCE LINES 65-71

.. code-block:: Python



    # .. warning::
    #    The current implementation of voronoi parcellation is CPU only, and is thus
    #    **very** slow in 3D ( > 1h).








.. GENERATED FROM PYTHON SOURCE LINES 72-87

.. code-block:: Python

    voronoi_weights = get_density("voronoi", traj)

    nufft_voronoi = get_operator(BACKEND)(
        traj, shape=mri_2D.shape, density=voronoi_weights, squeeze_dims=True
    )
    adjoint_voronoi = nufft_voronoi.adj_op(kspace)
    fig, axs = plt.subplots(1, 3, figsize=(15, 5))
    axs[0].imshow(abs(mri_2D))
    axs[0].set_title("Ground Truth")
    axs[1].imshow(abs(adjoint))
    axs[1].set_title("no density compensation")
    axs[2].imshow(abs(adjoint_voronoi))
    axs[2].set_title("Voronoi density compensation")





.. image-sg:: /generated/autoexamples/GPU/images/sphx_glr_example_density_002.png
   :alt: Ground Truth, no density compensation, Voronoi density compensation
   :srcset: /generated/autoexamples/GPU/images/sphx_glr_example_density_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Text(0.5, 1.0, 'Voronoi density compensation')



.. GENERATED FROM PYTHON SOURCE LINES 88-93

Cell Counting
-------------

Cell Counting attributes weights based on the number of trajectory point lying in a same k-space nyquist voxel.
This can be viewed as an approximation to the voronoi neth

.. GENERATED FROM PYTHON SOURCE LINES 93-100

.. code-block:: Python


    # .. note::
    #    Cell counting is faster than voronoi (especially in 3D), but is less precise.

    # The size of the niquist voxel can be tweak by using the osf parameter. Typically as the NUFFT (and by default in MRI-NUFFT) is performed at an OSF of 2









.. GENERATED FROM PYTHON SOURCE LINES 101-119

.. code-block:: Python

    cell_count_weights = get_density("cell_count", traj, shape=mri_2D.shape, osf=2.0)

    nufft_cell_count = get_operator(BACKEND)(
        traj,
        shape=mri_2D.shape,
        density=cell_count_weights,
        upsampfac=2.0,
        squeeze_dims=True,
    )
    adjoint_cell_count = nufft_cell_count.adj_op(kspace)
    fig, axs = plt.subplots(1, 3, figsize=(15, 5))
    axs[0].imshow(abs(mri_2D))
    axs[0].set_title("Ground Truth")
    axs[1].imshow(abs(adjoint))
    axs[1].set_title("no density compensation")
    axs[2].imshow(abs(adjoint_cell_count))
    axs[2].set_title("cell_count density compensation")




.. image-sg:: /generated/autoexamples/GPU/images/sphx_glr_example_density_003.png
   :alt: Ground Truth, no density compensation, cell_count density compensation
   :srcset: /generated/autoexamples/GPU/images/sphx_glr_example_density_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Text(0.5, 1.0, 'cell_count density compensation')



.. GENERATED FROM PYTHON SOURCE LINES 120-125

Manual Density Estimation
-------------------------

For some analytical trajectory it is also possible to determine the density compensation vector directly.
In radial trajectory for instance, a sample's weight can be determined from its distance to the center.

.. GENERATED FROM PYTHON SOURCE LINES 128-142

.. code-block:: Python

    flat_traj = traj.reshape(-1, 2)
    weights = np.sqrt(np.sum(flat_traj**2, axis=1))
    nufft = get_operator(BACKEND)(
        traj, shape=mri_2D.shape, density=weights, squeeze_dims=True
    )
    adjoint_manual = nufft.adj_op(kspace)
    fig, axs = plt.subplots(1, 3, figsize=(15, 5))
    axs[0].imshow(abs(mri_2D))
    axs[0].set_title("Ground Truth")
    axs[1].imshow(abs(adjoint))
    axs[1].set_title("no density compensation")
    axs[2].imshow(abs(adjoint_manual))
    axs[2].set_title("manual density compensation")




.. image-sg:: /generated/autoexamples/GPU/images/sphx_glr_example_density_004.png
   :alt: Ground Truth, no density compensation, manual density compensation
   :srcset: /generated/autoexamples/GPU/images/sphx_glr_example_density_004.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Text(0.5, 1.0, 'manual density compensation')



.. GENERATED FROM PYTHON SOURCE LINES 143-155

Operator-based method
=====================

Pipe's Method
-------------
Pipe's method is an iterative scheme, that use the interpolation and spreading kernel operator for computing the density compensation.

.. warning::
   If this method is widely used in the literature, there exists no convergence guarantees for it.

.. note::
   The Pipe method is currently only implemented for gpuNUFFT, finufft, and cufinufft backends.

.. GENERATED FROM PYTHON SOURCE LINES 157-171

.. code-block:: Python

    flat_traj = traj.reshape(-1, 2)
    nufft = get_operator(BACKEND)(
        traj, shape=mri_2D.shape, density={"name": "pipe", "osf": 2}, squeeze_dims=True
    )
    adjoint_manual = nufft.adj_op(kspace)
    fig, axs = plt.subplots(1, 3, figsize=(15, 5))
    axs[0].imshow(abs(mri_2D))
    axs[0].set_title("Ground Truth")
    axs[1].imshow(abs(adjoint))
    axs[1].set_title("no density compensation")
    axs[2].imshow(abs(adjoint_manual))
    axs[2].set_title("Pipe density compensation")
    print(nufft.density)




.. image-sg:: /generated/autoexamples/GPU/images/sphx_glr_example_density_005.png
   :alt: Ground Truth, no density compensation, Pipe density compensation
   :srcset: /generated/autoexamples/GPU/images/sphx_glr_example_density_005.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /volatile/github-ci-mind-inria/gpu_mind_runner/_work/mri-nufft/venv/lib/python3.10/site-packages/mrinufft/_utils.py:99: UserWarning: Samples will be rescaled to [-0.5, 0.5), assuming they were in [-pi, pi)
      warnings.warn(
    [0.01538814+0.j 0.02055799+0.j 0.0399904 +0.j ... 3.424798  +0.j
     2.943549  +0.j 2.680558  +0.j]




.. GENERATED FROM PYTHON SOURCE LINES 172-173

We can also do density compensation using cufinufft backend

.. GENERATED FROM PYTHON SOURCE LINES 175-188

.. code-block:: Python

    flat_traj = traj.reshape(-1, 2)
    nufft = get_operator(BACKEND)(
        traj, shape=mri_2D.shape, density={"name": "pipe", "osf": 2}, squeeze_dims=True
    )
    adjoint_manual = nufft.adj_op(kspace)
    fig, axs = plt.subplots(1, 3, figsize=(15, 5))
    axs[0].imshow(abs(mri_2D))
    axs[0].set_title("Ground Truth")
    axs[1].imshow(abs(adjoint))
    axs[1].set_title("no density compensation")
    axs[2].imshow(np.squeeze(abs(adjoint_manual)))
    axs[2].set_title("Pipe density compensation")
    print(nufft.density)



.. image-sg:: /generated/autoexamples/GPU/images/sphx_glr_example_density_006.png
   :alt: Ground Truth, no density compensation, Pipe density compensation
   :srcset: /generated/autoexamples/GPU/images/sphx_glr_example_density_006.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [0.01538813+0.j 0.020558  +0.j 0.03999041+0.j ... 3.4247985 +0.j
     2.9435487 +0.j 2.6805584 +0.j]





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 7.766 seconds)


.. _sphx_glr_download_generated_autoexamples_GPU_example_density.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/mind-inria/mri-nufft/gh-pages?urlpath=lab/tree/examples/generated/autoexamples/GPU/example_density.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: example_density.ipynb <example_density.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: example_density.py <example_density.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: example_density.zip <example_density.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
