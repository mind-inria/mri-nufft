
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "generated/autoexamples/trajectories/example_3D_trajectories.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_generated_autoexamples_trajectories_example_3D_trajectories.py>`
        to download the full example code. or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_generated_autoexamples_trajectories_example_3D_trajectories.py:


===============
3D Trajectories
===============

A collection of 3D non-Cartesian trajectories with analytical definitions.

.. GENERATED FROM PYTHON SOURCE LINES 11-25

Hereafter we detail and illustrate the different arguments used in the
parameterization of 3D non-Cartesian trajectories. Since most arguments
are redundant across the different patterns, some of the documentation
will refer to previous patterns for explanation.

Note that the examples hereafter only cover natively 3D trajectories
or famous 3D trajectories obtained from 2D. Examples on how to use
tools to make 3D trajectories out of 2D ones are presented in
:ref:`sphx_glr_generated_autoexamples_trajectories_example_trajectory_tools.py`

In this page in particular, we invite the user to manually run the script
to be able to manipulate the plot orientations with the matplotlib interface
to better visualize the 3D volumes.


.. GENERATED FROM PYTHON SOURCE LINES 25-34

.. code-block:: Python


    # External
    import matplotlib.pyplot as plt
    import numpy as np
    from utils import show_trajectories, show_trajectory

    # Internal
    import mrinufft as mn








.. GENERATED FROM PYTHON SOURCE LINES 35-38

Script options
==============
These options are used in the examples below as default values for all trajectories.

.. GENERATED FROM PYTHON SOURCE LINES 38-54

.. code-block:: Python


    # Trajectory parameters
    Nc = 120  # Number of shots
    Ns = 500  # Number of samples per shot
    in_out = False  # Choose between in-out or center-out trajectories
    tilt = "uniform"  # Angular distance between shots
    nb_repetitions = 6  # Number of stacks, rotations, cones, shells etc.
    nb_revolutions = 1  # Number of revolutions for base trajectories
    seed = 0  # Seed for random trajectories

    # Display parameters
    figure_size = 10  # Figure size for trajectory plots
    subfigure_size = 6  # Figure size for subplots
    one_shot = -5  # Highlight one shot in particular









.. GENERATED FROM PYTHON SOURCE LINES 55-81

Radial trajectories
===================

In this section are presented trajectories based on radial
lines oriented using different methods and structures.

Phyllotaxis radial
------------------

A 3D radial pattern with phyllotactic structure.

The radial shots are oriented according to a Fibonacci sphere
lattice, supposed to reproduce the phyllotaxis found in nature
through flowers, etc. It ensures an almost uniform distribution.

This function reproduces the proposition from [Pic+11]_, but the name
"spiral phyllotaxis" was changed to avoid confusion with
actual spirals.

Arguments:

- ``Nc (int)``: number of individual shots
- ``Ns (int)``: number of samples per shot
- ``in_out (bool)``: define whether the shots should travel toward
  the center then outside (in-out) or not (center-out). ``(default False)``


.. GENERATED FROM PYTHON SOURCE LINES 81-86

.. code-block:: Python


    trajectory = mn.initialize_3D_phyllotaxis_radial(Nc, Ns, in_out=in_out)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_001.png
   :alt: example 3D trajectories
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 87-93

``Nc (int)``
~~~~~~~~~~~~

The number of individual shots, here 3D radial lines, used to cover the
k-space. More shots means better coverage but also longer acquisitions.


.. GENERATED FROM PYTHON SOURCE LINES 93-99

.. code-block:: Python


    arguments = [Nc // 4, Nc // 2, Nc, Nc * 2]
    function = lambda x: mn.initialize_3D_phyllotaxis_radial(x, Ns, in_out=in_out)
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_002.png
   :alt: 30, 60, 120, 240
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 100-106

``Ns (int)``
~~~~~~~~~~~~

The number of samples per shot. More samples means that either
the acquisition window is lengthened or the sampling rate is increased.


.. GENERATED FROM PYTHON SOURCE LINES 106-112

.. code-block:: Python


    arguments = [10, 25, 40, 100]
    function = lambda x: mn.initialize_3D_phyllotaxis_radial(Nc, x, in_out=in_out)
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_003.png
   :alt: 10, 25, 40, 100
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 113-129

``in_out (bool)``
~~~~~~~~~~~~~~~~~

It allows switching between different ways to define how the shot should
travel through the k-space:

- in-out: starting from the outer regions, then passing through the center
  then going back to outer regions, often on the opposite side (radial, cones)
- center-out or center-center: when ``in_out=False`` the trajectory will start
  at the center, but depending on the specific trajectory formula the path might
  end up in the outer regions (radial, spiral, cones, etc)
  or back to the center (rosette, lissajous).

Note that the behavior of both ``tilt`` and ``width`` are automatically adapted
to the changes to avoid having to update them too when switching ``in_out``.


.. GENERATED FROM PYTHON SOURCE LINES 129-135

.. code-block:: Python


    arguments = [True, False]
    function = lambda x: mn.initialize_3D_phyllotaxis_radial(Nc, Ns, in_out=x)
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_004.png
   :alt: True, False
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 136-158

Golden means radial
-------------------

A 3D radial pattern with golden means-based structure.

The radial shots are oriented using multidimensional golden means,
which are derived from modified Fibonacci sequences by an eigenvalue
approach, to provide a temporally stable acquisition with widely
spread shots at all time.

This function reproduces the proposition from [Cha+09]_, with
in addition the option to switch between center-out
and in-out radial shots.

Arguments:

- ``Nc (int)``: number of individual shots. See 3D radial
- ``Ns (int)``: number of samples per shot. See 3D radial
- ``in_out (bool)``: define whether the shots should travel toward
  the center then outside (in-out) or not (center-out).
  ``(default False)``. See 3D radial


.. GENERATED FROM PYTHON SOURCE LINES 158-163

.. code-block:: Python


    trajectory = mn.initialize_3D_golden_means_radial(Nc, Ns, in_out=in_out)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_005.png
   :alt: example 3D trajectories
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 164-187

Wong radial
-------------------

A 3D radial pattern with a spiral structure.

The radial shots are oriented according to an archimedean spiral
over a sphere surface, for each interleave.

This function reproduces the proposition from [WR94]_, with
in addition the option to switch between center-out
and in-out radial shots.

Arguments:

- ``Nc (int)``: number of individual shots. See 3D radial
- ``Ns (int)``: number of samples per shot. See 3D radial
- ``nb_interleaves (int)``: number of implicit interleaves
  defining the shots order for a more structured k-space
  distribution over time. ``(default 1)``
- ``in_out (bool)``: define whether the shots should travel toward
  the center then outside (in-out) or not (center-out).
  ``(default False)``. See 3D radial


.. GENERATED FROM PYTHON SOURCE LINES 187-192

.. code-block:: Python


    trajectory = mn.initialize_3D_wong_radial(Nc, Ns, in_out=in_out)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_006.png
   :alt: example 3D trajectories
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 193-217

Park radial
-------------------

A 3D radial pattern with a spiral structure.

The radial shots are oriented according to an archimedean spiral
over a sphere surface, shared uniformly between all interleaves.

This function reproduces the proposition from [Par+16]_,
itself based on the work from [WR94]_, with
in addition the option to switch between center-out
and in-out radial shots.

Arguments:

- ``Nc (int)``: number of individual shots. See 3D radial
- ``Ns (int)``: number of samples per shot. See 3D radial
- ``nb_interleaves (int)``: number of implicit interleaves
  defining the shots order for a more structured k-space
  distribution over time. ``(default 1)``
- ``in_out (bool)``: define whether the shots should travel toward
  the center then outside (in-out) or not (center-out).
  ``(default False)``. See 3D radial


.. GENERATED FROM PYTHON SOURCE LINES 217-222

.. code-block:: Python


    trajectory = mn.initialize_3D_park_radial(Nc, Ns, in_out=in_out)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_007.png
   :alt: example 3D trajectories
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_007.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 223-250

Freeform trajectories
=====================

In this section are presented trajectories in all kinds of shapes
and relying on different principles.

3D Cones
--------

A common pattern composed of 3D cones oriented all over within a sphere.

Arguments:

- ``Nc (int)``: number of individual shots. See 3D radial
- ``Ns (int)``: number of samples per shot. See 3D radial
- ``tilt (str, float)``: angle between each consecutive shot (in radians).
  ``(default "golden")``
- ``in_out (bool)``: define whether the shots should travel toward
  the center then outside (in-out) or not (center-out).
  ``(default False)``. See 3D radial
- ``nb_zigzags (float)``: number of revolutions over a center-out shot.
  ``(default 5)``
- ``spiral (str, float)``: type of spiral defined through the general
  archimedean equation. ``(default "archimedes")``. See 2D spiral
- ``width (float)``: cone width factor, normalized to densely cover the k-space
  by default. ``(default 1)``


.. GENERATED FROM PYTHON SOURCE LINES 250-255

.. code-block:: Python


    trajectory = mn.initialize_3D_cones(Nc, Ns, in_out=in_out)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_008.png
   :alt: example 3D trajectories
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_008.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 256-265

``tilt (str, float)``
~~~~~~~~~~~~~~~~~~~~~

The angle between each consecutive shots, either in radians or as a
string defining some default mods such as “uniform” for
:math:`2 \pi / N_c`, or “golden” and “mri golden” for the different
common definitions of golden angles. The angle is automatically adapted
when the ``in_out`` argument is switched to keep the same behavior.


.. GENERATED FROM PYTHON SOURCE LINES 265-271

.. code-block:: Python


    arguments = ["uniform", "golden", "mri-golden", np.pi / 17]
    function = lambda x: mn.initialize_3D_cones(Nc, Ns, tilt=x, in_out=in_out)
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_009.png
   :alt: uniform, golden, mri-golden, 0.18479956785822313
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_009.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 272-278

``nb_zigzags (float)``
~~~~~~~~~~~~~~~~~~~~~~

The number of “zigzags”, or revolutions around the 3D cone on a center-out shot
(doubled overall for in-out trajectories)


.. GENERATED FROM PYTHON SOURCE LINES 278-284

.. code-block:: Python


    arguments = [0.5, 2, 5, 10]
    function = lambda x: mn.initialize_3D_cones(Nc, Ns, in_out=in_out, nb_zigzags=x)
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_010.png
   :alt: 0.5, 2, 5, 10
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_010.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 285-293

``spiral (str, float)``
~~~~~~~~~~~~~~~~~~~~~~~


The shape of the spiral defined and documented in
``initialize_2D_spiral``. Both ``"archimedes"`` and ``"fermat"``
spirals are available as string options for convenience.


.. GENERATED FROM PYTHON SOURCE LINES 293-299

.. code-block:: Python


    arguments = ["archimedes", "fermat", 0.5, 1.5]
    function = lambda x: mn.initialize_3D_cones(Nc, Ns, in_out=in_out, spiral=x)
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_011.png
   :alt: archimedes, fermat, 0.5, 1.5
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_011.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 300-308

``width (float)``
~~~~~~~~~~~~~~~~~

The cone width normalized such that ``width = 1`` corresponds to
non-overlapping cones covering the whole k-space sphere, and
therefore ``width > 1`` creates overlap between cone regions and
``width < 1`` tends to more radial patterns.


.. GENERATED FROM PYTHON SOURCE LINES 308-314

.. code-block:: Python


    arguments = [0.2, 1, 2, 3]
    function = lambda x: mn.initialize_3D_cones(Nc, Ns, in_out=in_out, width=x)
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_012.png
   :alt: 0.2, 1, 2, 3
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_012.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 315-340

FLORET
------

A pattern introduced in [Pip+11]_ composed of Fermat spirals
folded into cones. The acronym stands for Fermat Looped, Orthogonally
Encoded Trajectories. Most arguments are related either to
``initialize_2D_spiral`` or to ``tools.conify``.

Arguments:

- ``Nc (int)``: number of individual shots. See 3D radial
- ``Ns (int)``: number of samples per shot. See 3D radial
- ``in_out (bool)``: define whether the shots should travel toward
  the center then outside (in-out) or not (center-out).
  ``(default False)``. See 3D radial
- ``nb_revolutions (float)``: number of revolutions performed from the
  center. ``(default 1)``. See 2D spiral
- ``spiral (str, float)``: type of spiral defined through the general
  archimedean equation. ``(default "fermat")``. See 2D spiral
- ``cone_tilt (float)``: angle tilt between consecutive cones
  around the :math:`k_z`-axis. ``(default "golden")``. See ``tools.conify``
- ``max_angle (float)``: maximum angle of the cones. ``(default pi / 2)``.
  See ``tools.conify``
- ``axes (tuple)``: axes over which cones are created, by default (2,)


.. GENERATED FROM PYTHON SOURCE LINES 340-350

.. code-block:: Python


    trajectory = mn.initialize_3D_floret(
        Nc * nb_repetitions,
        Ns,
        in_out=in_out,
        nb_revolutions=nb_revolutions,
        max_angle=np.pi / 3,
    )[::-1]
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)




.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_013.png
   :alt: example 3D trajectories
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_013.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 351-364

``axes (tuple)``
~~~~~~~~~~~~~~~~

Indices of the different axes over which cones are created,
with 0, 1, 2 corresponding to :math:`k_x, k_y, k_z` respectively.
The ``Nc`` shots and ``nb_cones`` are distributed
over all axes, and therefore should be divisible by ``len(axes)``.

The point is to provide an efficient coverage by reducing ``max_angle``
to avoid redundancy around one axis, but still cover the whole
k-space sphere by duplicating cones along several axes, as initially
proposed by [Pip+11]_.


.. GENERATED FROM PYTHON SOURCE LINES 365-377

.. code-block:: Python


    arguments = [(0,), (1,), (0, 1), (0, 1, 2)]
    function = lambda x: mn.initialize_3D_floret(
        Nc * nb_repetitions,
        Ns,
        in_out=in_out,
        nb_revolutions=nb_revolutions,
        max_angle=np.pi / 4,
        axes=x,
    )[::-1]
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)




.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_014.png
   :alt: (0,), (1,), (0, 1), (0, 1, 2)
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_014.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 378-384

.. code-block:: Python


    show_trajectories(
        function, arguments, one_shot=one_shot, subfig_size=subfigure_size, dim="2D"
    )





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_015.png
   :alt: (0,), (1,), (0, 1), (0, 1, 2)
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_015.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 385-408

Wave-CAIPI
----------

A pattern introduced in [Bil+15]_ composed of helices evolving
in the same direction and packed together,
inherited from trajectories such as CAIPIRINHA and
Bunched Phase-Encoding (BPE) designed to better spread aliasing
and facilitate reconstruction.

Arguments:

- ``Nc (int)``: number of individual shots. See 3D radial
- ``Ns (int)``: number of samples per shot. See 3D radial
- ``nb_revolutions (str, float)``: number of revolution of the helices.
  ``(default 5)``
- ``width (float)``: helix width factor, normalized to densely
  cover the k-space by default. ``(default 1)``.
- ``packing (str)``: packing method used to position the helices.
  ``(default "triangular")``
- ``shape (str, float)``: shape over the 2D kx-ky plane to pack with shots.
  ``(default "circle")``
- ``spacing (tuple(int, int))``: Spacing between helices over the
  2D :math:`k_x`-:math:`k_y` plane normalized similarly to `width`. ``(default (1, 1))``

.. GENERATED FROM PYTHON SOURCE LINES 408-412

.. code-block:: Python


    trajectory = mn.initialize_3D_wave_caipi(Nc, Ns)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)




.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_016.png
   :alt: example 3D trajectories
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_016.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 413-418

``nb_revolutions (float)``
~~~~~~~~~~~~~~~~~~~~~~~~~~

The number of revolutions of the helices from bottom to top.


.. GENERATED FROM PYTHON SOURCE LINES 418-423

.. code-block:: Python


    arguments = [0.5, 2.5, 5, 10]
    function = lambda x: mn.initialize_3D_wave_caipi(Nc, Ns, nb_revolutions=x)
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)




.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_017.png
   :alt: 0.5, 2.5, 5, 10
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_017.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 424-434

``width (float)``
~~~~~~~~~~~~~~~~~

The helix diameter normalized such that ``width = 1`` corresponds to
non-overlapping shots densely covering the k-space shape (for square packing),
and therefore ``width > 1`` creates overlap between cone regions and
``width < 1`` tends to more radial patterns.

See ``packing`` for more details about coverage.


.. GENERATED FROM PYTHON SOURCE LINES 434-439

.. code-block:: Python


    arguments = [0.2, 1, 2, 3]
    function = lambda x: mn.initialize_3D_wave_caipi(Nc, Ns, width=x)
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)




.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_018.png
   :alt: 0.2, 1, 2, 3
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_018.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 440-456

``packing (str)``
~~~~~~~~~~~~~~~~~

The method used to pack circles of same size within an arbitrary ``shape``.
The available methods are ``"triangular"`` and ``"square"`` for regular tiling
over dense grids, and ``"circular"``, ``fibonacci`` and ``"random"`` for
irregular packing.
Different aliases are available, such as ``"triangle"``, ``"hexagon"`` instead
of ``"triangular"``.

Note that ``"triangular"`` and ``fibonacci`` packings have slightly overlapping
helices, as their widths correspond to that of an optimaly packed
triangular/hexagonal grid.
The ``"random"`` packing also naturally overlaps as the positions are determined
following a uniform distribution over :math:`k_x` and :math:`k_y` dimensions.


.. GENERATED FROM PYTHON SOURCE LINES 456-461

.. code-block:: Python


    arguments = ["triangular", "square", "circular", "fibonacci", "random"]
    function = lambda x: mn.initialize_3D_wave_caipi(Nc, Ns, packing=x)
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)




.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_019.png
   :alt: triangular, square, circular, fibonacci, random
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_019.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 462-467

.. code-block:: Python


    show_trajectories(
        function, arguments, one_shot=one_shot, subfig_size=subfigure_size, dim="2D"
    )




.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_020.png
   :alt: triangular, square, circular, fibonacci, random
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_020.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 468-482

``shape (str, float)``
~~~~~~~~~~~~~~~~~~~~~~

The 2D shape defined over the :math:`k_x`-:math:`k_y` plane
and where the helices should be packed. Aliases are available for convenience,
namely ``"circle"``, ``"square"``, ``"diamond"``, but shapes are primarily
defined through the p-norm of the 2D coordinates following the convention
of the ``ord`` parameter from ``numpy.linalg.norm``.

The shapes are approximately respected depending on the available ``Nc``
parameter, and extra shots on the edges will be placed in priority to have
a minimal 2-norm (eliminating the diagonals) except for circles with infinity-norm
(accumulating over the diagonals).


.. GENERATED FROM PYTHON SOURCE LINES 482-487

.. code-block:: Python


    arguments = ["circle", "square", "diamond", 0.5]
    function = lambda x: mn.initialize_3D_wave_caipi(Nc, Ns, shape=x)
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)




.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_021.png
   :alt: circle, square, diamond, 0.5
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_021.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 488-493

.. code-block:: Python


    show_trajectories(
        function, arguments, one_shot=one_shot, subfig_size=subfigure_size, dim="2D"
    )




.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_022.png
   :alt: circle, square, diamond, 0.5
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_022.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 494-503

``spacing (tuple(int, int))``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The spacing between helices over the :math:`k_x`-:math:`k_y` plane, mostly
defined for ``"square"`` packing. It is defined to correspond to the ``width``
unit, itself automatically matching the helix diameters, which can cause more
complex behaviors for other packing methods as the diameters are normalized to
fit within the cubic k-space.


.. GENERATED FROM PYTHON SOURCE LINES 503-508

.. code-block:: Python


    arguments = [(1, 1), (2, 1), (1, 2), (2.3, 1.8)]
    function = lambda x: mn.initialize_3D_wave_caipi(Nc, Ns, packing="square", spacing=x)
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)




.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_023.png
   :alt: (1, 1), (2, 1), (1, 2), (2.3, 1.8)
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_023.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 509-515

.. code-block:: Python


    show_trajectories(
        function, arguments, one_shot=one_shot, subfig_size=subfigure_size, dim="2D"
    )





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_024.png
   :alt: (1, 1), (2, 1), (1, 2), (2.3, 1.8)
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_024.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 516-546

Seiffert spirals / Yarnball
---------------------------

A recent pattern with tightly controlled gradient norms using radially
modulated Seiffert spirals, based on Jacobi elliptic functions.
Note that Seiffert spirals more commonly refer to a curve evolving
over a sphere surface rather than a volume, with the advantage of
having a constant speed and angular velocity. The MR trajectory
is obtained by increasing progressively the radius of the sphere.

This implementation follows the proposition from [SMR18]_ based on
works from [Er00]_ and [Br09]_. The pattern is also referred to as
Yarnball by a different team [SB21]_, as a nod to the Yarn trajectory
pictured in [IN95]_, even though both admittedly share little in common.

Arguments:

- ``Nc (int)``: number of individual shots. See 3D radial
- ``Ns (int)``: number of samples per shot. See 3D radial
- ``curve_index (float)``: Index controlling curvature from 0 (flat) to 1 (curvy).
  ``(default 0.3)``
- ``nb_revolutions (float)``: number of revolutions or elliptic periods.
  ``(default 1)``
- ``axis_tilt (str, float)``: angle between each consecutive shot (in radians)
  while descending over the :math:`k_z`-axis ``(default "golden")``. See 3D cones
- ``spiral_tilt (str, float)``: angle of the spiral within its own axis,
  defined from center to its outermost point ``(default "golden")``.
- ``in_out (bool)``: define whether the shots should travel toward the center
  then outside (in-out) or not (center-out). ``(default False)``. See 3D radial


.. GENERATED FROM PYTHON SOURCE LINES 546-551

.. code-block:: Python


    trajectory = mn.initialize_3D_seiffert_spiral(Nc, Ns, in_out=in_out)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_025.png
   :alt: example 3D trajectories
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_025.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 552-559

``curve_index (float)``
~~~~~~~~~~~~~~~~~~~~~~~

An index defined over :math:`[0, 1)` controling the curvature, with :math:`0`
corresponding to a planar spiral, and increasing the length and exploration of
the curve while asymptotically approaching :math:`1`.


.. GENERATED FROM PYTHON SOURCE LINES 559-567

.. code-block:: Python


    arguments = [0, 0.3, 0.9, 0.99]
    function = lambda x: mn.initialize_3D_seiffert_spiral(
        Nc, Ns, in_out=in_out, curve_index=x
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_026.png
   :alt: 0, 0.3, 0.9, 0.99
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_026.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 568-576

``nb_revolutions (float)``
~~~~~~~~~~~~~~~~~~~~~~~~~~

Number of revolutions, or simply the number of times a curve reaches its
original orientation. For regular Seiffert spirals, it corresponds to the
number of times the shot reaches the starting pole of the sphere. It
subsequently defines the length of the curve.


.. GENERATED FROM PYTHON SOURCE LINES 576-587

.. code-block:: Python


    arguments = [0, 0.5, 1, 2]
    function = lambda x: mn.initialize_3D_seiffert_spiral(
        Nc,
        Ns,
        in_out=in_out,
        nb_revolutions=x,
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_027.png
   :alt: 0, 0.5, 1, 2
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_027.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 588-599

``axis_tilt (str, float)``
~~~~~~~~~~~~~~~~~~~~~~~~~~

Angle between consecutive shots while descending along the :math:`k_z`-axis.
The ``"golden"`` value chosen as default provides an almost even distribution
over the k-space sphere by relying on Fibonacci lattice, and therefore it should
be changed carefully when relevant.

Note that in the examples below, the ``spiral_tilt`` argument is set to 0
for clarity.


.. GENERATED FROM PYTHON SOURCE LINES 599-611

.. code-block:: Python


    arguments = [0, "uniform", "golden", 20 * 2 * np.pi / Nc]
    function = lambda x: mn.initialize_3D_seiffert_spiral(
        Nc,
        Ns,
        in_out=in_out,
        axis_tilt=x,
        spiral_tilt=0,
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_028.png
   :alt: 0, uniform, golden, 1.0471975511965976
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_028.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 612-625

``spiral_tilt (str, float)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Define the angle of the spiral within its own axis after precession of the spiral
along the :math:`k_z`-axis. Since the precession is applied through Rodrigues'
coefficients and Seiffert spirals are asymetric, their orientation right after
the precession can be quite biased and yield unbalanced densities.

The method proposed in [SMR18]_ to handle that issue is to rotate the spirals
along their own axes, but the exact way to choose the rotation is not specified.
Rather than picking random angles, we decided to provide the conventional "tilt"
argument.


.. GENERATED FROM PYTHON SOURCE LINES 625-636

.. code-block:: Python


    arguments = [0, "uniform", "golden", 20 * 2 * np.pi / Nc]
    function = lambda x: mn.initialize_3D_seiffert_spiral(
        Nc,
        Ns,
        in_out=in_out,
        axis_tilt="golden",
        spiral_tilt=x,
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)




.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_029.png
   :alt: 0, uniform, golden, 1.0471975511965976
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_029.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 637-662

ECCENTRIC
---------

This is a reproduction of the proposition from [Kla+24]_.
It creates trajectories as uniformly distributed circles,
with a pseudo rosette-like structure at the center to ensure
its coverage. ECCENTRIC stands for ECcentric Circle ENcoding
TRajectorIes for Compressed sensing.

Arguments:

- ``Nc (int)``: number of individual shots. See radial
- ``Ns (int)``: number of samples per shot. See radial
- ``nb_stacks (int)``: number of stack layers along the
  :math:`k_z`-axis
- ``radius_ratio (float)``: radius of each circle relatively
  to the k-space radius.
- ``center_ratio (float)``: proportion of shots positioned around
  the center into a pseudo-rosette pattern (default 0).
- ``nb_revolutions (float)``: number of revolutions per circle
  (default 1). See spiral
- ``min_distance (float)``: minimum allowed distance between
  consecutive circles relatively to the k-space radius (default 0).
- ``seed (int)``: random seed for reproducibility, used only
  to draw the circle centers (default None).

.. GENERATED FROM PYTHON SOURCE LINES 662-668

.. code-block:: Python


    trajectory = mn.initialize_3D_eccentric(
        Nc, Ns, nb_stacks=nb_repetitions, radius_ratio=0.3, seed=seed
    )
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)




.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_030.png
   :alt: example 3D trajectories
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_030.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 669-675

``nb_stacks (int)``
~~~~~~~~~~~~~~~~~~~

The number of stack layers along the :math:`k_z`-axis. The number
of shot varies per stack to match the density of a sphere.


.. GENERATED FROM PYTHON SOURCE LINES 675-682

.. code-block:: Python


    arguments = [2, 5, 7, 13]
    function = lambda x: mn.initialize_3D_eccentric(
        Nc=Nc, Ns=Ns, nb_stacks=x, radius_ratio=0.3, seed=seed
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)




.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_031.png
   :alt: 2, 5, 7, 13
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_031.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 683-689

``radius_ratio (float)``
~~~~~~~~~~~~~~~~~~~~~~~~

The radius of each circle relatively to the k-space radius. It should be below
0.5 otherwise the shots are not able to cross the k-space center.


.. GENERATED FROM PYTHON SOURCE LINES 689-696

.. code-block:: Python


    arguments = [0.05, 0.2, 0.35, 0.5]
    function = lambda x: mn.initialize_3D_eccentric(
        Nc=Nc, Ns=Ns, nb_stacks=nb_repetitions, radius_ratio=x, seed=seed
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)




.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_032.png
   :alt: 0.05, 0.2, 0.35, 0.5
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_032.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 697-703

``center_ratio (float)``
~~~~~~~~~~~~~~~~~~~~~~~~

The proportion of shots positioned around the center into a pseudo-rosette pattern.
The goal is to ensure its coverage despite the trajectories being random otherwise.


.. GENERATED FROM PYTHON SOURCE LINES 703-711

.. code-block:: Python


    arguments = [0, 0.3, 0.6, 1]
    function = lambda x: mn.initialize_3D_eccentric(
        Nc=Nc, Ns=Ns, nb_stacks=nb_repetitions, radius_ratio=0.3, center_ratio=x, seed=seed
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_033.png
   :alt: 0, 0.3, 0.6, 1
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_033.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 712-741

Shell trajectories
==================

In this section are presented trajectories that are composed of concentric
shells, i.e. shots arranged over spherical surfaces.

Helical shells
--------------

An arrangement of spirals covering sphere surfaces, often referred to as
concentric shells. Here the name was changed to avoid confusion with
other trajectories sharing this principle.

This implementation follows the proposition from [YRB06]_ but the idea
is much older and can be traced back at least to [IN95]_.

Arguments:

- ``Nc (int)``: number of individual shots. See 3D radial
- ``Ns (int)``: number of samples per shot. See 3D radial
- ``nb_shells (int)``: number of shells used to partition the k-space.
  It should be lower than or equal to ``Nc``.
- ``spiral_reduction (float)``: factor to reduce the automatic number of
  spiral revolution per shot. ``(default 1)``
- ``shell_tilt (str, float)``: angle between each consecutive shell (in radians).
  ``(default "intergaps")``
- ``shot_tilt (str, float)``: angle between each consecutive shot
  over a sphere (in radians). ``(default "uniform")``


.. GENERATED FROM PYTHON SOURCE LINES 741-746

.. code-block:: Python


    trajectory = mn.initialize_3D_helical_shells(Nc, Ns, nb_shells=nb_repetitions)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_034.png
   :alt: example 3D trajectories
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_034.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 747-752

``nb_shells (int)``
~~~~~~~~~~~~~~~~~~~

Number of shells, i.e. concentric spheres, used to partition the k-space sphere.


.. GENERATED FROM PYTHON SOURCE LINES 752-760

.. code-block:: Python


    arguments = [1, 2, nb_repetitions // 2, nb_repetitions]
    function = lambda x: mn.initialize_3D_helical_shells(
        Nc=x, Ns=Ns, nb_shells=x, spiral_reduction=2
    )
    show_trajectories(function, arguments, one_shot=False, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_035.png
   :alt: 1, 2, 3, 6
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_035.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 761-771

``spiral_reduction (float)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Normalized factor controlling the curvature of the spirals over the sphere surfaces.
The curvature is determined by ``Nc`` and ``Ns`` automatically based on [YRB06]_
in order to provide a coverage with minimal aliasing, but the curve velocities and
accelerations might make them incompatible with gradient and slew rate constraints.
Therefore we provided ``spiral_reduction`` to reduce (or increase) the pre-determined
spiral curvature.


.. GENERATED FROM PYTHON SOURCE LINES 771-779

.. code-block:: Python


    arguments = [0.5, 1, 2, 4]
    function = lambda x: mn.initialize_3D_helical_shells(
        Nc=Nc, Ns=Ns, nb_shells=nb_repetitions, spiral_reduction=x
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_036.png
   :alt: 0.5, 1, 2, 4
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_036.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 780-785

``shell_tilt (str, float)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Angle between each consecutive shells (in radians).


.. GENERATED FROM PYTHON SOURCE LINES 785-793

.. code-block:: Python


    arguments = ["uniform", "intergaps", "golden", 3.1415]
    function = lambda x: mn.initialize_3D_helical_shells(
        Nc=Nc, Ns=Ns, nb_shells=nb_repetitions, spiral_reduction=2, shell_tilt=x
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_037.png
   :alt: uniform, intergaps, golden, 3.1415
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_037.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 794-802

``shot_tilt (str, float)``
~~~~~~~~~~~~~~~~~~~~~~~~~~

Angle between each consecutive shot over a shell/sphere (in radians).
Note that since the number of shots per shell is determined automatically
for each individual shell following a density provided in [YRB06]_, it
is advised to use adaptive keywords such as "uniform" rather than hard values.


.. GENERATED FROM PYTHON SOURCE LINES 802-810

.. code-block:: Python


    arguments = ["uniform", "intergaps", "golden", 0.1]
    function = lambda x: mn.initialize_3D_helical_shells(
        Nc=Nc, Ns=Ns, nb_shells=nb_repetitions, spiral_reduction=2, shot_tilt=x
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_038.png
   :alt: uniform, intergaps, golden, 0.1
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_038.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 811-831

Annular shells
--------------

An exclusive trajectory composed of re-arranged rings covering
concentric shells with minimal redundancy, based on the work from [HM11]_.
The rings are cut in halves and recombined in order to provide
more homogeneous shot lengths as compared to a spherical stack
of rings.

Arguments:

- ``Nc (int)``: number of individual shots. See 3D radial
- ``Ns (int)``: number of samples per shot. See 3D radial
- ``nb_shells (int)``: number of shells used to partition the k-space.
  It should be lower than or equal to ``Nc``. See helical shells.
- ``shell_tilt (str, float)``: angle between each consecutive shell (in radians).
  ``(default pi)``. See helical shells.
- ``ring_tilt (str, float)``: angle used to rotate the half-sphere of rings
  (in radians). ``(default pi / 2)``


.. GENERATED FROM PYTHON SOURCE LINES 831-836

.. code-block:: Python


    trajectory = mn.initialize_3D_annular_shells(Nc, Ns, nb_shells=nb_repetitions)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_039.png
   :alt: example 3D trajectories
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_039.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 837-854

``ring_tilt (float)``
~~~~~~~~~~~~~~~~~~~~~~

Angle (in radians) defining the rotation between the two halves of
each spheres, and therefore also the rings recombination. A zero angle,
as seen on the first example, results in a simple stack-of-rings, while
an angle of :math:`\pi / 2` on the third example makes the ring take
a right angle.

Note that the angle is discretized over each sphere depending on the
number of rings, and therefore the angle might be inaccurate over smaller
shells.

An angle of :math:`\pi / 2` allows reaching the best shot length homogeneity,
and it partitions the spheres into several connex curves composed of exactly
two shots.


.. GENERATED FROM PYTHON SOURCE LINES 854-862

.. code-block:: Python


    arguments = [0, np.pi / 4, np.pi / 2, 3 * np.pi / 4]
    function = lambda x: mn.initialize_3D_annular_shells(
        Nc, Ns, nb_shells=nb_repetitions, ring_tilt=x
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_040.png
   :alt: 0, 0.7853981633974483, 1.5707963267948966, 2.356194490192345
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_040.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 863-886

Seiffert shells
---------------

An exclusive trajectory composed of re-arranged Seiffert spirals
covering concentric shells. All curves have a constant speed and
angular velocity, depending on the size of the sphere they belong to.

This implementation is inspired by the propositions from [YRB06]_ and [SMR18]_,
and also based on works from [Er00]_ and [Br09]_.

Arguments:

- ``Nc (int)``: number of individual shots. See 3D radial
- ``Ns (int)``: number of samples per shot. See 3D radial
- ``curve_index (float)``: Index controlling curvature from 0 (flat) to 1 (curvy).
  ``(default 0.3)``. See Seiffert spirals
- ``nb_revolutions (float)``: number of revolutions or elliptic periods.
  ``(default 1)``.  See Seiffert spirals
- ``shell_tilt (str, float)``: angle between each consecutive shell (in radians).
  ``(default "intergaps")``. See helical shells
- ``shot_tilt (str, float)``: angle between each consecutive shot
  over a sphere (in radians). ``(default "uniform")``. See helical shells


.. GENERATED FROM PYTHON SOURCE LINES 886-891

.. code-block:: Python


    trajectory = mn.initialize_3D_seiffert_shells(Nc, Ns, nb_shells=nb_repetitions)
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_041.png
   :alt: example 3D trajectories
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_041.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 892-931

fMRI trajectories
=================

In this section are presented long trajectories designed for
functional MRI to cover the k-space in a few shots, often composed
of multiple readouts.

TURBINE
-------

The TURBINE (Trajectory Using Radially Batched Internal Navigator Echoes)
trajectory as proposed in [MGM10]_. It consists of EPI-like multi-echo
planes rotated around any axis (here :math:`k_z`-axis) in a radial fashion.

Note that our implementation also proposes to segment the planes
into several shots instead of just one, and includes the proposition
from [GMC22]_ to also accelerate within the blades by skipping lines
but while alternating them between blades.

Arguments:

- ``Nc (int)``: number of individual shots. See 3D radial
- ``Ns_readouts (int)``: number of samples per readout. See 3D radial
- ``Ns_transitions (int)``: number of samples per transition between
  two readouts.
- ``nb_blades (int)``: number of blades used to group readouts into
  and partition the k-space. It should be lower than ``Nc`` and divide it.
- ``blade_tilt (str, float)``: angle between each consecutive blades
  over the :math:`k_z`-axis (in radians). ``(default "uniform")``
- ``nb_trains (int)``: number of resulting shots, or readout trains,
  such that each of them will be composed of :math:`n` readouts with
  ``Nc = n * nb_trains``. If ``"auto"`` then ``nb_trains`` is set
  to ``nb_blades``.
- ``skip_factor (int)``: factor defining the way different blades alternate
  to skip lines, forming groups of ``skip_factor`` non-redundant blades.
  ``(default 1)``
- ``in_out (bool)``: define whether the shots should travel toward the center
  then outside (in-out) or not (center-out). ``(default True)``. See 3D radial


.. GENERATED FROM PYTHON SOURCE LINES 931-939

.. code-block:: Python


    nb_blades = Nc // 15
    trajectory = mn.initialize_3D_turbine(
        Nc, Ns_readouts=Ns, Ns_transitions=Ns // 10, nb_blades=nb_blades
    )
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_042.png
   :alt: example 3D trajectories
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_042.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 940-947

``Ns_transitions (int)``
~~~~~~~~~~~~~~~~~~~~~~~~

Number of samples per transition between two readouts.
Smoother transitions are achieved with more points, but it means longer
waiting times between readouts if they are split during acquisition.


.. GENERATED FROM PYTHON SOURCE LINES 947-958

.. code-block:: Python


    arguments = [1, 50, 100, 200]
    function = lambda x: mn.initialize_3D_turbine(
        Nc=Nc,
        Ns_readouts=Ns,
        Ns_transitions=x,
        nb_blades=nb_blades,
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_043.png
   :alt: 1, 50, 100, 200
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_043.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 959-966

``nb_blades (int)``
~~~~~~~~~~~~~~~~~~~

Number of blades used to group readouts into
and partition the k-space. More blades means fewer lines per blade.
It should be lower than ``Nc`` and divide it.


.. GENERATED FROM PYTHON SOURCE LINES 966-977

.. code-block:: Python


    arguments = [Nc // 5, Nc // 15, Nc // 30, Nc // 60]
    function = lambda x: mn.initialize_3D_turbine(
        Nc=Nc,
        Ns_readouts=Ns,
        Ns_transitions=Ns // 10,
        nb_blades=x,
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_044.png
   :alt: 24, 8, 4, 2
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_044.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 978-983

``blade_tilt (str, float)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Angle between each consecutive blades over the :math:`k_z`-axis (in radians)


.. GENERATED FROM PYTHON SOURCE LINES 983-994

.. code-block:: Python


    arguments = ["uniform", "golden"]
    function = lambda x: mn.initialize_3D_turbine(
        Nc=Nc,
        Ns_readouts=Ns,
        Ns_transitions=Ns // 10,
        nb_blades=nb_blades,
        blade_tilt=x,
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)




.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_045.png
   :alt: uniform, golden
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_045.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 995-1001

.. code-block:: Python


    show_trajectories(
        function, arguments, one_shot=one_shot, subfig_size=subfigure_size, dim="2D"
    )





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_046.png
   :alt: uniform, golden
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_046.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 1002-1009

``nb_trains (int)``
~~~~~~~~~~~~~~~~~~~

Number of resulting shots, or readout trains, such that each of them
will be composed of :math:`n` readouts with ``Nc = n * nb_trains``.
If ``"auto"`` then ``nb_trains`` is set to ``nb_blades``.


.. GENERATED FROM PYTHON SOURCE LINES 1009-1021

.. code-block:: Python


    arguments = [nb_blades, 3 * nb_blades, 5 * nb_blades, 15 * nb_blades]
    function = lambda x: mn.initialize_3D_turbine(
        Nc=Nc,
        Ns_readouts=Ns,
        Ns_transitions=Ns // 10,
        nb_blades=nb_blades,
        nb_trains=x,
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_047.png
   :alt: 8, 24, 40, 120
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_047.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 1022-1033

``skip_factor (int)``
~~~~~~~~~~~~~~~~~~~~~

Factor defining the way different blades alternate to skip lines,
forming groups of ``skip_factor`` non-redundant blades.

This enables the in-plane acceleration proposed by [GMC22]_ by
increasing ``skip_factor`` and ``nb_blades`` together by a same
factor. Note that using ``skip_factor`` superior to ``nb_blades``
as below results in k-space areas being not covered by any blade.


.. GENERATED FROM PYTHON SOURCE LINES 1033-1044

.. code-block:: Python


    arguments = [1, 2, 4, nb_blades + 2]
    function = lambda x: mn.initialize_3D_turbine(
        Nc=Nc,
        Ns_readouts=Ns,
        Ns_transitions=Ns // 10,
        nb_blades=nb_blades,
        skip_factor=x,
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)




.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_048.png
   :alt: 1, 2, 4, 10
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_048.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 1045-1056

.. code-block:: Python


    show_trajectories(
        function,
        arguments,
        one_shot=one_shot,
        subfig_size=subfigure_size,
        dim="2D",
        axes=(1, 2),
    )





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_049.png
   :alt: 1, 2, 4, 10
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_049.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 1057-1097

REPI
----

The REPI (Radial Echo Planar Imaging) trajectory proposed in [RMS22]_
and officially inspired from TURBINE proposed in [MGM10]_.
It consists of multi-echo stacks of lines or spirals rotated around any axis
(here :math:`k_z`-axis) in a radial fashion, but each stack is also slightly
shifted along the rotation axis in order to be entangled with the others
without redundancy. This feature is similar to choosing ``skip_factor``
equal to ``nb_blades`` in TURBINE.

Note that our implementation also proposes to segment the planes/stacks
into several shots, instead of just one. Spirals can also be customized
beyond the classic Archimedean spiral.

Arguments:

- ``Nc (int)``: number of individual shots. See 3D radial
- ``Ns_readouts (int)``: number of samples per readout. See 3D radial
- ``Ns_transitions (int)``: number of samples per transition between
  two readouts. See TURBINE
- ``nb_blades (int)``: number of blades used to group readouts into
  and partition the k-space. It should be lower than ``Nc`` and divide it.
  See TURBINE
- ``nb_blade_revolutions (float)``: number of revolutions over
  lines/spirals within a blade over the :math:`k_z` axis. See TURBINE
- ``blade_tilt (str, float)``: angle between each consecutive blades
  over the :math:`k_z`-axis (in radians).
  ``(default "uniform")``. See TURBINE
- ``nb_trains (int)``: number of resulting shots, or readout trains,
  such that each of them will be composed of :math:`n` readouts with
  ``Nc = n * nb_trains``. If ``"auto"`` then ``nb_trains`` is set
  to ``nb_blades``. See TURBINE
- ``nb_spiral_revolutions (float)``: number of revolutions performed
  from the center. ``(default 1)``. See 2D spiral
- ``spiral (str, float)``: type of spiral defined through the general
  archimedean equation. ``(default "archimedes")``. See 2D spiral
- ``in_out (bool)``: define whether the shots should travel toward the center
  then outside (in-out) or not (center-out). ``(default True)``. See 3D radial


.. GENERATED FROM PYTHON SOURCE LINES 1098-1110

.. code-block:: Python


    trajectory = mn.initialize_3D_repi(
        Nc,
        Ns_readouts=Ns,
        Ns_transitions=Ns // 10,
        nb_blades=nb_blades,
        nb_blade_revolutions=nb_revolutions,
        nb_spiral_revolutions=nb_revolutions,
    )
    show_trajectory(trajectory, figure_size=figure_size, one_shot=one_shot)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_050.png
   :alt: example 3D trajectories
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_050.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 1111-1121

``nb_blade_revolutions (float)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Number of revolutions over lines/spirals within a blade
over the :math:`k_z` axis.

Note that increasing it also tends to increase the distance
between consecutive lines/spirals, requiring higher gradients
and slew rates.


.. GENERATED FROM PYTHON SOURCE LINES 1121-1134

.. code-block:: Python


    arguments = [0, 0.5, 1, 2]
    function = lambda x: mn.initialize_3D_repi(
        Nc=Nc,
        Ns_readouts=Ns,
        Ns_transitions=Ns // 10,
        nb_blades=nb_blades,
        nb_blade_revolutions=x,
        nb_spiral_revolutions=0,
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_051.png
   :alt: 0, 0.5, 1, 2
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_051.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 1135-1137

Same but with a spiral pattern instead of radial.


.. GENERATED FROM PYTHON SOURCE LINES 1138-1151

.. code-block:: Python


    arguments = [0, 0.5, 1, 2]
    function = lambda x: mn.initialize_3D_repi(
        Nc=Nc,
        Ns_readouts=Ns,
        Ns_transitions=Ns // 10,
        nb_blades=nb_blades,
        nb_blade_revolutions=x,
        nb_spiral_revolutions=nb_revolutions,
    )
    show_trajectories(function, arguments, one_shot=one_shot, subfig_size=subfigure_size)





.. image-sg:: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_052.png
   :alt: 0, 0.5, 1, 2
   :srcset: /generated/autoexamples/trajectories/images/sphx_glr_example_3D_trajectories_052.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 1152-1222

References
==========

.. [WR94] Wong, Sam TS, and Mark S. Roos.
   "A strategy for sampling on a sphere applied
   to 3D selective RF pulse design."
   Magnetic Resonance in Medicine 32, no. 6 (1994): 778-784.
.. [IN95] Irarrazabal, Pablo, and Dwight G. Nishimura.
   "Fast three dimensional magnetic resonance imaging."
   Magnetic Resonance in Medicine 33, no. 5 (1995): 656-662.
.. [Er00] Erdös, Paul.
   "Spiraling the earth with C. G. J. Jacobi."
   American Journal of Physics 68, no. 10 (2000): 888-895.
.. [YRB06] Shu, Yunhong, Stephen J. Riederer, and Matt A. Bernstein.
   "Three‐dimensional MRI with an undersampled spherical shells trajectory."
   Magnetic Resonance in Medicine 56, no. 3 (2006): 553-562.
.. [Br09] Brizard, Alain J.
   "A primer on elliptic functions with applications in classical mechanics."
   European journal of physics 30, no. 4 (2009): 729.
.. [Cha+09] Chan, Rachel W., Elizabeth A. Ramsay,
   Charles H. Cunningham, and Donald B. Plewes.
   "Temporal stability of adaptive 3D radial MRI
   using multidimensional golden means."
   Magnetic Resonance in Medicine 61, no. 2 (2009): 354-363.
.. [MGM10] McNab, Jennifer A., Daniel Gallichan, and Karla L. Miller.
   "3D steady‐state diffusion‐weighted imaging with trajectory using
   radially batched internal navigator echoes (TURBINE)."
   Magnetic Resonance in Medicine 63, no. 1 (2010): 235-242.
.. [HM11] Gerlach, Henryk, and Heiko von der Mosel.
   "On sphere-filling ropes."
   The American Mathematical Monthly 118, no. 10 (2011): 863-876
.. [Pic+11] Piccini, Davide, Arne Littmann,
   Sonia Nielles‐Vallespin, and Michael O. Zenge.
   "Spiral phyllotaxis: the natural way to construct
   a 3D radial trajectory in MRI."
   Magnetic resonance in medicine 66, no. 4 (2011): 1049-1056.
.. [Pip+11] Pipe, James G., Nicholas R. Zwart, Eric A. Aboussouan,
   Ryan K. Robison, Ajit Devaraj, and Kenneth O. Johnson.
   "A new design and rationale for 3D orthogonally
   oversampled k‐space trajectories."
   Magnetic resonance in medicine 66, no. 5 (2011): 1303-1311.
.. [Bil+15] Bilgic, Berkin, Borjan A. Gagoski, Stephen F. Cauley, Audrey P. Fan,
   Jonathan R. Polimeni, P. Ellen Grant, Lawrence L. Wald, and Kawin Setsompop.
   "Wave‐CAIPI for highly accelerated 3D imaging."
   Magnetic resonance in medicine 73, no. 6 (2015): 2152-2162.
.. [Par+16] Park, Jinil, Taehoon Shin, Soon Ho Yoon,
   Jin Mo Goo, and Jang‐Yeon Park.
   "A radial sampling strategy for uniform k‐space coverage
   with retrospective respiratory gating
   in 3D ultrashort‐echo‐time lung imaging."
   NMR in Biomedicine 29, no. 5 (2016): 576-587.
.. [SMR18] Speidel, Tobias, Patrick Metze, and Volker Rasche.
   "Efficient 3D Low-Discrepancy k-Space Sampling
   Using Highly Adaptable Seiffert Spirals."
   IEEE Transactions on Medical Imaging 38, no. 8 (2018): 1833-1840.
.. [SB21] Stobbe, Robert W., and Christian Beaulieu.
   "Three‐dimensional Yarnball k‐space acquisition for accelerated MRI."
   Magnetic Resonance in Medicine 85, no. 4 (2021): 1840-1854.
.. [GMC22] Graedel, Nadine N., Karla L. Miller, and Mark Chiew.
   "Ultrahigh resolution fMRI at 7T using radial‐cartesian TURBINE sampling."
   Magnetic Resonance in Medicine 88, no. 5 (2022): 2058-2073.
.. [RMS22] Rettenmeier, Christoph A., Danilo Maziero, and V. Andrew Stenger.
   "Three dimensional radial echo planar imaging for functional MRI."
   Magnetic Resonance in Medicine 87, no. 1 (2022): 193-206.
.. [Kla+24] Klauser, Antoine, Bernhard Strasser, Wolfgang Bogner,
   Lukas Hingerl, Sebastien Courvoisier, Claudiu Schirda,
   Bruce R. Rosen, Francois Lazeyras, and Ovidiu C. Andronesi.
   "ECCENTRIC: a fast and unrestrained approach for high-resolution
   in vivo metabolic imaging at ultra-high field MR".
   Imaging Neuroscience 2 (2024): 1-20.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (1 minutes 28.025 seconds)


.. _sphx_glr_download_generated_autoexamples_trajectories_example_3D_trajectories.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/mind-inria/mri-nufft/gh-pages?urlpath=lab/tree/examples/generated/autoexamples/trajectories/example_3D_trajectories.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: example_3D_trajectories.ipynb <example_3D_trajectories.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: example_3D_trajectories.py <example_3D_trajectories.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: example_3D_trajectories.zip <example_3D_trajectories.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
